# HTML Native Agent + 前端设计导向：最终开发方案（2026-02-19）

## 0. 前言：对 Codex 方案的 Review

本文在阅读 Codex 原方案（`HTML_Native_Agent与前端设计导向机制_完整开发方案_2026-02-18.md`）和逐文件审计当前代码库后得出。以下先记录关键 review 结论，再给出最终方案。

---

### 0.1 Codex 方案做对的事

| 正确点 | 说明 |
|---|---|
| Mermaid 耦合点定位全面 | 7 个文件均已识别，无遗漏 |
| 4-PR 可独立回滚策略 | 风险控制合理 |
| `window.__LUMI_RENDER_DONE__` 就绪信号 | 比 `networkidle` 稳定，方向正确 |
| `design_spec` JSON 契约 | 是结构化生成的核心，有价值 |
| 静态规则门控在 VL 之前 | 低成本高稳定，节约 VL 调用 |
| 迁移开关 `agent_enable_mermaid` | 降低硬切风险 |

---

### 0.2 Codex 方案的关键问题（9 条）

**问题 1：PR 顺序错误——渲染增强应在设计 Agent 之前**

原方案顺序：PR-1（Native化）→ PR-2（Design Agent）→ PR-3（渲染增强）。

但 PR-2 的 Design Agent 如果在 `pure_css` 约束下运行，DesignPlanner 规划的复杂 ECharts 页面根本无法渲染。这让 PR-2 的价值大打折扣。

**修正**：将渲染增强的 Renderer 核心改造（`enhanced_web` + ready信号 + 白名单）提前到 PR-2，和 Design Agent 并行落地，而不是滞后到 PR-3。

---

**问题 2：`@lru_cache` + 运行时开关不兼容**

`app/config.py:64` 使用 `@lru_cache()` 使 `get_settings()` 成为单例，且 `app/agent/service.py:79` 在 `__init__` 时就固定了 `tools` 列表：

```python
tools = [generate_html_image, generate_mermaid_image, check_image_quality]
```

这意味着 `agent_enable_mermaid` 特性开关**只能在服务启动时生效**，无法运行时动态切换。方案文档应明确这一限制，避免误解。

**修正**：文档标注"feature flag 仅在重启生效"；切换完成后 PR-4 直接删除 flag 和 Mermaid 代码。

---

**问题 3：DesignPlanner 架构实现路径未明确**

原方案说"在 ImageGenAgenticService 内实现轻量多角色流程"，但未指定具体实现方式。当前架构是 LangGraph 单 Agent 循环，添加 DesignPlanner 有三种路径：

- **方案 A（推荐）**：在 `generate_image()` 主调用之前，增加一次独立的"规划 LLM 调用"，产出 `design_spec` JSON，再拼接进 HumanMessage 发给主 Agent
- **方案 B**：注册 `plan_design` 工具，让主 Agent 自行决策何时调用规划
- **方案 C**：重构 LangGraph 图，增加独立节点（复杂度高，不推荐）

**修正**：选用方案 A，实现最简、侵入最小，不需要改动 LangGraph 图结构。

---

**问题 4：RepairLoop 与现有重试机制重叠**

当前 `prompt.py:47-48` 已有重试逻辑：
> "如果质量检查连续失败 2 次（同一请求累计 3 次渲染），直接返回最后一次图片 URL"

新方案的 RepairLoop 如果在 Agent 外层再加重试，会产生双重重试叠加，导致单次请求最多渲染 9 次（3×3）。

**修正**：RepairLoop 不独立于 Agent 外层，而是在 VisualCritic 发现问题后，**通过明确的 repair instruction 注入 HumanMessage**，继续在同一 Agent 会话内处理，利用现有的重试上限（2次），不新增循环层。

---

**问题 5：静态检查模块位置模糊**

原方案同时提出 `app/tool/html_lint.py` 和 `app/agent/frontend_design/static_checks.py` 两个位置。

静态检查是纯文本分析（不依赖截图），应在渲染之前、Agent 调用 `generate_html_image` 之后的 VisualCritic 流程中运行，而非 LangChain Tool。

**修正**：统一使用 `app/agent/frontend_design/static_checks.py`，作为内部 utility 而非 @tool 注册。

---

**问题 6：Tailwind 预编译方案不可行**

Tailwind 预编译需要知道所有用到的 class 名称（PurgeCSS 扫描源码）。但 LLM 动态生成 HTML，无法提前确定类名，因此预编译并不实用。

可行选项：
- **Play CDN**（`<script src="https://cdn.tailwindcss.com"></script>`）：最简单，适合内部环境网络可达时
- **本地 Full CSS Bundle**：将完整的 Tailwind CSS 文件（约 3.5MB）作为本地静态文件挂载，Playwright 通过 `file://` 或 route 拦截注入。适合网络受限环境
- **不用 Tailwind，只用自定义 CSS**：短期最稳，LLM 生成内联 CSS 即可

**修正**：P0 阶段不引入 Tailwind，专注 ECharts。Tailwind 作为 P2 可选增强，届时评估本地 Full Bundle 方案。

---

**问题 7：网络环境风险未评估**

当前 config 显示 LLM 和 VL 都在内网（`10.220.77.197`），这强烈暗示部署环境可能无法访问外网 CDN（`cdn.jsdelivr.net`）。

**修正**：在 PR-2 实施前，需要先验证：
1. Playwright 容器内是否可访问 jsdelivr.net/unpkg.com
2. 如不可达，优先采用"本地静态资源挂载"方案（Playwright `route` 拦截 + 内存中注入 ECharts bundle）

---

**问题 8：`image_qa.py` 文档引用需同步清理**

`app/tool/image_qa.py:35` 的 docstring 提到 `generate_mermaid_image`，在 Mermaid 下线后需同步更新，Codex 方案在 §4.5 文档清理中遗漏了这一点。

---

**问题 9：`design_spec` → HtmlComposer 的注入机制未说明**

设计规格 JSON 如何传递给生成 HTML 的 LLM 调用，原方案没有说明。

**修正**：在"方案 A（预处理 LLM 调用）"架构下，`design_spec` 以结构化形式拼入 HumanMessage 前缀，例如：

```
[设计规格 - 请严格按此生成 HTML]
{...design_spec json...}

用户原始需求：{original_query}
```

---

## 1. 目标确认（继承 Codex 方案）

**范围**：HTML Native Agent + 前端设计导向机制，不引入扩散模型，不新增独立后端服务。

**两大目标**：
1. 移除 Mermaid 工具链，服务改为纯 HTML Native Agent
2. 引入"设计规划 → 生成 → 渲染 → 静态检查 → VL 审稿"闭环，提升复杂页面质量

---

## 2. 修正后的整体 PR 策略

| PR | 内容 | 工作日估算 | 可独立回滚 |
|---|---|---|---|
| **PR-1** | HTML Native 化（Mermaid 下线）| D1–D3 | ✅ |
| **PR-2** | Renderer 增强（enhanced_web + ready信号 + 白名单）| D4–D6 | ✅ |
| **PR-3** | 前端设计导向 Agent V1（DesignPlanner + VisualCritic）| D7–D10 | ✅ |
| **PR-4** | 质量门控 + 指标 + 文档收口 | D11–D12 | ✅ |

**关键变化**：将原 PR-3（渲染增强）提前为新 PR-2，保证设计 Agent 上线时已有 `enhanced_web` 渲染能力。

---

## 3. PR-1：HTML Native 化（D1–D3）

### 3.1 改动清单

**Step 1 — 引入 Feature Flag（0.5天）**

`app/config.py` 新增：
```python
agent_enable_mermaid: bool = False  # 迁移窗口期可临时开启，服务重启生效
```
`.env.example` 同步新增 `AGENT_ENABLE_MERMAID=false` 及说明注释。

> ⚠️ 注意：由于 `@lru_cache` 机制，此 flag 仅在服务重启时生效，无法运行时热切换。

**Step 2 — Agent 工具表 HTML-only（0.5天）**

`app/agent/service.py:79`，按 flag 条件组装 tools：
```python
from ..config import get_settings

_s = get_settings()
_base_tools = [generate_html_image, check_image_quality]
if _s.agent_enable_mermaid:
    from ..tool import generate_mermaid_image
    _base_tools.insert(1, generate_mermaid_image)

tools = _base_tools
```

**Step 3 — 提示词 HTML Native 化（0.5天）**

`app/agent/prompt.py` 修改：
- 删除 Mermaid 工具说明（第 16-18 行）
- 删除工具选择规则中的 Mermaid 分支（第 26-30 行）
- 删除工作流中的 "generate_mermaid_image" 引用（第 37 行）
- 删除 Mermaid 编写规范（第 68-74 行）
- 更新 HTML 编写规范：增加"流程图/时序图/架构图 → 使用 SVG 或 CSS 绘制节点连线"的指导
- 暂时保留"严禁 JS 和外部库"约束（PR-2 完成后再放开）

**Step 4 — 删除 Mermaid 代码（1天）**（在 Step 1-3 验证稳定后执行）

- 删除 `app/tool/mermaid_render.py`
- `app/tool/__init__.py`：删除 `generate_mermaid_image` 导入和导出
- `app/util/renderer.py`：删除 `render_mermaid_to_image` 函数（第 160-259 行）
- `app/config.py`：删除 `mermaid_cdn_url` 字段
- `.env.example`：删除 `MERMAID_CDN_URL` 条目
- `app/agent/service.py`：删除 Mermaid 相关 import 和 flag 逻辑

**Step 5 — 文档与描述清理（0.5天）**

- `README.md`、`README_CN.md`：由"HTML + Mermaid"改为"HTML Native"
- `app/main.py`：更新服务描述文案
- `app/tool/image_qa.py:35` docstring：删除对 `generate_mermaid_image` 的引用

### 3.2 PR-1 验收标准

- `rg mermaid app/` 结果为空（排除注释中的历史说明）
- Agent 日志中 tools 列表只含 `generate_html_image`, `check_image_quality`
- 流程图、时序图、架构图类请求可返回 HTML 渲染结果（不报工具缺失）
- 多轮对话和 `check_image_quality` 链路正常

---

## 4. PR-2：Renderer 增强（D4–D6）

### 4.1 前置：网络环境探针

**在编写代码前，先执行环境验证**（CI 或手动）：
```bash
# 在 Playwright 运行环境内测试 CDN 可达性
python -c "
from playwright.sync_api import sync_playwright
with sync_playwright() as p:
    b = p.chromium.launch(headless=True, args=['--no-sandbox'])
    page = b.new_page()
    page.goto('https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js', timeout=10000)
    print('CDN reachable:', page.url)
    b.close()
"
```

根据结果选择渲染策略：
- 可达 → 直接 CDN 引入（标准路径）
- 不可达 → 本地静态 bundle 注入（见 4.3 节兜底方案）

### 4.2 `app/config.py` 新增配置

```python
# Renderer 增强配置
render_html_mode: str = "enhanced_web"       # pure_css | enhanced_web
render_allowed_hosts: str = "cdn.jsdelivr.net,unpkg.com,fonts.googleapis.com"
render_ready_timeout_ms: int = 12000
render_block_external_images: bool = True
```

### 4.3 `app/util/renderer.py` 核心改造

新增 `render_html_to_image_enhanced` 函数（或以 `mode` 参数扩展现有函数），核心改动：

**① 渲染模式判断**
```python
settings = get_settings()
use_enhanced = settings.render_html_mode == "enhanced_web"
```

**② 替换等待策略**

当前（有问题）：
```python
page.set_content(html_content, wait_until="networkidle", timeout=30000)
page.wait_for_load_state("domcontentloaded")
page.wait_for_timeout(800)
```

改为：
```python
page.set_content(html_content, wait_until="domcontentloaded", timeout=15000)

if use_enhanced:
    # 等待应用级就绪信号（ECharts 等库渲染完成后必须设置此标志）
    try:
        page.wait_for_function(
            "() => window.__LUMI_RENDER_DONE__ === true",
            timeout=settings.render_ready_timeout_ms
        )
    except Exception:
        # 兜底：等待关键选择器或固定超时
        try:
            page.wait_for_selector("canvas, svg.echarts-svg", timeout=3000)
        except Exception:
            page.wait_for_timeout(2000)
else:
    page.wait_for_timeout(800)
```

**③ 网络白名单拦截**

```python
if use_enhanced:
    allowed_hosts = set(settings.render_allowed_hosts.split(","))

    def handle_route(route):
        url = route.request.url
        from urllib.parse import urlparse
        host = urlparse(url).netloc
        # 放行：同源（data:, blob:, file:）和白名单域名
        if not host or host in allowed_hosts:
            route.continue_()
        elif settings.render_block_external_images and route.request.resource_type == "image":
            route.abort()
        else:
            route.continue_()  # 其他资源暂时放行，记录日志

    page.route("**/*", handle_route)
```

**④ 失败信息结构化**

在返回 `error` 时新增 `error_code` 字段：
```python
# 现有 error_code 枚举
ERROR_CODES = {
    "BLANK_PAGE": "HTML rendered a blank page",
    "FILE_TOO_SMALL": "Rendered image file too small",
    "READY_TIMEOUT": "Page ready signal timeout",
    "LIB_LOAD_FAILED": "External library failed to load",
}
```

**⑤ 本地静态 bundle 兜底方案**（网络不可达时）

将 ECharts bundle 存放于 `app/static/echarts.min.js`（约 1.2MB），在 `page.route` 中拦截 jsdelivr/unpkg 的 ECharts 请求，用本地文件内容响应：

```python
ECHARTS_LOCAL_PATH = os.path.join(os.path.dirname(__file__), "../static/echarts.min.js")

def handle_route(route):
    if "echarts" in route.request.url and os.path.exists(ECHARTS_LOCAL_PATH):
        with open(ECHARTS_LOCAL_PATH, "rb") as f:
            route.fulfill(content_type="application/javascript", body=f.read())
    else:
        route.continue_()
```

### 4.4 `app/tool/html_render.py` 新增参数

```python
@tool
def generate_html_image(html_code: str, width: int = 1200, enhanced: bool = True) -> str:
    """将 HTML 代码渲染为图片。
    ...
    参数:
        enhanced: 是否启用增强模式（允许 JS 和受控外部库），默认 True
    """
```

### 4.5 PR-2 验收标准

- ECharts 渲染成功率（10 个基准用例）≥ 90%
- 空白图率 ≤ 2%
- 平均渲染时延 P50 ≤ 8s
- 网络白名单拦截有效：非白名单域名请求被阻断并记录日志

---

## 5. PR-3：前端设计导向 Agent V1（D7–D10）

### 5.1 架构决策：方案 A（预处理 LLM 调用）

在 `generate_image()` 调用主 Agent 之前，增加一次独立 LLM 调用（同一个 `model` 实例），产出结构化 `design_spec`，再将 spec + 原始需求拼接为增强版 HumanMessage 发给主 Agent。

```
用户请求
    ↓
[DesignPlanner LLM call] → design_spec JSON
    ↓
[增强 HumanMessage = design_spec + 原始需求]
    ↓
[主 Agent: HTML生成 → 渲染 → 静态检查 → VL审稿 → 可能修复]
    ↓
返回图片
```

**选此方案理由**：
- 不改动 LangGraph 图结构，风险最低
- `design_spec` 可记录到 Langfuse，可观测
- 未来可升级为独立节点（改造路径清晰）

### 5.2 新增文件结构

```
app/agent/
├── frontend_design/
│   ├── __init__.py
│   ├── planner.py          # DesignPlanner：产出 design_spec
│   ├── spec_schema.py      # design_spec Pydantic schema
│   ├── static_checks.py    # 静态规则检查器（在 VL 之前运行）
│   └── templates.py        # 可复用 HTML 片段模板（可选，P2）
```

### 5.3 `spec_schema.py`：design_spec 数据契约

```python
from pydantic import BaseModel
from typing import Literal, Optional

class VisualTokens(BaseModel):
    primary_color: str = "#2563EB"
    background_color: str = "#F8FAFC"
    text_color: str = "#1E293B"
    accent_color: str = "#F59E0B"
    font_scale: Literal["compact", "normal", "large"] = "normal"
    border_radius: Literal["none", "sm", "md", "lg"] = "md"
    density: Literal["compact", "comfortable", "spacious"] = "comfortable"

class SectionSpec(BaseModel):
    type: Literal["header", "kpi_cards", "chart", "table", "text", "timeline", "diagram"]
    title: Optional[str] = None
    content_hint: str   # 该区块的内容目标描述
    chart_type: Optional[Literal["bar", "line", "pie", "scatter", "radar"]] = None
    use_echarts: bool = False

class DesignSpec(BaseModel):
    page_type: Literal["dashboard", "infographic", "report", "landing", "diagram"]
    layout: Literal["single_column", "two_column", "grid", "sidebar"]
    sections: list[SectionSpec]
    visual_tokens: VisualTokens
    min_sections: int = 3       # 静态检查阈值
    use_echarts: bool = False
    max_width: int = 1200
```

### 5.4 `planner.py`：DesignPlanner 实现

```python
"""
DesignPlanner: 将用户需求转为结构化 design_spec。
一次独立 LLM 调用，不依赖 LangGraph Agent 状态。
"""
import json
import logging
from langchain_core.messages import HumanMessage, SystemMessage

from .spec_schema import DesignSpec

logger = logging.getLogger(__name__)

PLANNER_SYSTEM_PROMPT = """你是一个专业的前端设计规划师。
接收用户的图片/页面需求，输出一份结构化 JSON 设计规格（design_spec）。

规则：
1. 只输出合法 JSON，不输出任何其他文字
2. 优先使用丰富的信息层级（多 section）
3. 若需求涉及数据可视化，将 use_echarts 设为 true
4. page_type 选择最贴近需求的类型
5. visual_tokens 要有明确的品牌感（避免默认灰白）

输出格式严格遵循 DesignSpec schema。"""

def plan_design(query: str, model) -> DesignSpec | None:
    """
    调用 LLM 将用户需求转为 design_spec。
    失败时返回 None，调用方降级到无规格的直接生成。
    """
    try:
        messages = [
            SystemMessage(content=PLANNER_SYSTEM_PROMPT),
            HumanMessage(content=f"用户需求：{query}\n\n请输出 design_spec JSON："),
        ]
        response = model.invoke(messages)
        spec_dict = json.loads(response.content)
        spec = DesignSpec(**spec_dict)
        logger.info("[DesignPlanner] spec: page_type=%s, sections=%d, use_echarts=%s",
                    spec.page_type, len(spec.sections), spec.use_echarts)
        return spec
    except Exception as e:
        logger.warning("[DesignPlanner] Failed to generate spec, falling back: %s", e)
        return None
```

### 5.5 `static_checks.py`：静态规则检查器

在 VL 调用之前、渲染成功之后，对 HTML 源码做轻量文本分析：

```python
"""
HTML 静态质量检查器。
在调用 VL 模型之前运行，低成本过滤明显质量问题。
"""
import re
from dataclasses import dataclass

PLACEHOLDER_PATTERNS = [
    r'\bTODO\b', r'\blorem ipsum\b', r'示例文本', r'占位符',
    r'placeholder text', r'sample data'
]

@dataclass
class StaticCheckResult:
    passed: bool
    issues: list[str]
    suggestions: list[str]

def check_html_quality(html: str, spec=None) -> StaticCheckResult:
    issues = []
    suggestions = []

    # 1. 禁止占位词
    for pattern in PLACEHOLDER_PATTERNS:
        if re.search(pattern, html, re.IGNORECASE):
            issues.append(f"包含占位词：{pattern}")
            suggestions.append("替换所有占位词为真实内容")

    # 2. 最小字号检查（禁止 font-size < 10px）
    small_fonts = re.findall(r'font-size:\s*([0-9]+)px', html)
    if any(int(s) < 10 for s in small_fonts):
        issues.append("存在小于 10px 的字体（可读性差）")
        suggestions.append("将所有字号提升至 12px 以上")

    # 3. 结构复杂度（如果有 spec，检查 section 数量）
    if spec and spec.min_sections > 0:
        section_count = len(re.findall(r'<(section|div)[^>]*class=["\'][^"\']*section', html, re.IGNORECASE))
        # 宽松匹配，只要有足够的顶级容器
        card_count = len(re.findall(r'class=["\'][^"\']*card', html, re.IGNORECASE))
        if section_count + card_count < spec.min_sections:
            issues.append(f"内容区块数量不足（检测到 {section_count+card_count} 个，建议 >= {spec.min_sections}）")
            suggestions.append("增加更多内容区块以提升信息密度")

    # 4. ECharts ready 信号检查（如果声明使用 ECharts）
    if spec and spec.use_echarts:
        if "__LUMI_RENDER_DONE__" not in html:
            issues.append("ECharts 页面缺少渲染就绪信号 window.__LUMI_RENDER_DONE__")
            suggestions.append("在 ECharts setOption 后添加 window.__LUMI_RENDER_DONE__ = true")

    passed = len(issues) == 0
    return StaticCheckResult(passed=passed, issues=issues, suggestions=suggestions)
```

### 5.6 `app/agent/service.py` 集成 DesignPlanner

在 `generate_image()` 方法中，在 `agent.invoke()` 之前插入规划步骤：

```python
from .frontend_design.planner import plan_design
from .frontend_design.spec_schema import DesignSpec
import json

def generate_image(self, query: str, conversation_id: str, user_id: str = "") -> str:
    # ...（现有代码）...

    # DesignPlanner 预处理（仅对首轮或明确重绘的请求生效）
    enhanced_query = query
    spec: DesignSpec | None = None

    is_first_turn = self._is_first_turn(conversation_id)  # 判断是否是新会话首轮
    if is_first_turn:
        spec = plan_design(query, model=get_main_model())
        if spec:
            spec_json = spec.model_dump_json(indent=2)
            enhanced_query = (
                f"[设计规格 - 请严格按此规格生成页面]\n{spec_json}\n\n"
                f"用户原始需求：{query}"
            )
            logger.info("[%s][%s] DesignSpec injected", self.service_name, conversation_id)

    messages = [HumanMessage(content=enhanced_query)]
    # ...（后续 agent.invoke 不变）...
```

**判断首轮的方式**（利用 LangGraph MemorySaver）：
```python
def _is_first_turn(self, conversation_id: str) -> bool:
    """通过 MemorySaver 检查是否为该会话的首条消息。"""
    config = {"configurable": {"thread_id": conversation_id}}
    try:
        state = self.agent.get_state(config)
        return len(state.values.get("messages", [])) == 0
    except Exception:
        return True
```

### 5.7 Prompt 同步更新（PR-3 时）

在 PR-2 完成渲染增强后，更新 `app/agent/prompt.py`：

**删除约束**（第 55-56 行）：
```
- **严禁依赖任何外部资源**：不使用外部图片、字体文件、JS 库（禁止 Chart.js、ECharts、D3.js、Tailwind CDN 等）
- **严禁使用 JavaScript**：所有视觉效果必须用纯 HTML + CSS 实现
```

**新增约束**：
```
- 允许在受控白名单内使用外部 JS 库（ECharts），但必须遵循以下规范：
  - ECharts 引入：`<script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>`
  - 每个使用 JS 的页面，必须在所有图表渲染完成后设置：`window.__LUMI_RENDER_DONE__ = true`
  - 若不使用 ECharts，仍然使用纯 HTML+CSS 实现

### ECharts 编写规范
- 初始化：`const chart = echarts.init(document.getElementById('chart-id'));`
- 必须定义完整 `option` 对象（包含 title、legend、xAxis/yAxis、series）
- 渲染完成后立即设置就绪信号：
  ```javascript
  chart.setOption(option);
  window.__LUMI_RENDER_DONE__ = true;
  ```
- 多图表时，在最后一个 setOption 后设置就绪信号
```

### 5.8 PR-3 验收标准

- 首轮请求 DesignSpec 注入率 ≥ 95%（日志验证）
- 复杂页面（dashboard/report）一次通过率 ≥ 75%
- ECharts 图表渲染成功率 ≥ 90%
- VL 平均分 ≥ 7.5（相比当前基线提升）
- 多轮编辑不触发 DesignPlanner（`is_first_turn=False` 分支正确）

---

## 6. PR-4：质量门控 + 指标 + 收口（D11–D12）

### 6.1 静态检查集成进工具链

在 `app/tool/html_render.py` 渲染成功后，调用静态检查，结果附加到返回 JSON：

```python
from ..agent.frontend_design.static_checks import check_html_quality

# 渲染成功后
static_result = check_html_quality(html_code)
if not static_result.passed:
    # 将问题追加到返回结果，供 Agent 修复
    result["static_check"] = {
        "passed": False,
        "issues": static_result.issues,
        "suggestions": static_result.suggestions,
    }
```

### 6.2 Langfuse 埋点新增维度

在 `generate_image()` 的 config metadata 中新增：
```python
"metadata": {
    ...,
    "design_spec_injected": spec is not None,
    "page_type": spec.page_type if spec else "unknown",
    "use_echarts": spec.use_echarts if spec else False,
}
```

### 6.3 API Schema 扩展（可选）

`app/api/schemas.py` 的请求体增加：
```python
render_mode: Literal["auto", "pure_css", "enhanced_web"] = "auto"
design_mode: Literal["auto", "standard", "frontend_pro"] = "auto"
```

### 6.4 最终验收标准

| 维度 | 目标 |
|---|---|
| Mermaid 代码残留 | `rg mermaid app/` 为空 |
| 复杂页面一次通过率 | ≥ 80% |
| VL 平均分 | ≥ 8（30条基准集） |
| 空白图率 | ≤ 2% |
| 端到端 P95 时延 | ≤ 15s（含规划+渲染+VL） |
| 新增模块单元测试 | `static_checks.py`, `spec_schema.py`, `planner.py` 有测试 |

---

## 7. 测试策略

### 7.1 基准用例集（30条，PR-3 上线前建立）

| 类型 | 数量 | 关键验证点 |
|---|---|---|
| Dashboard（KPI+图表+表格）| 8 | ECharts 渲染、多区块、数据可读 |
| 数据报告（图文混排）| 6 | 文字层级、段落结构 |
| 流程/架构图（原 Mermaid 强项）| 6 | SVG 节点连线、方向正确 |
| 营销落地页 | 5 | 视觉美感、色彩层次 |
| 信息图（timeline/对比）| 5 | 信息密度、对齐规范 |

### 7.2 单元测试重点

- `static_checks.py`：覆盖正例（通过）和反例（占位词、小字、无ready信号）
- `spec_schema.py`：Pydantic 校验边界值
- `planner.py`：mock LLM 响应，验证 fallback 逻辑
- `renderer.py`：验证 `enhanced_web` vs `pure_css` 等待策略分支

---

## 8. 风险与回滚

| 风险 | 概率 | 影响 | 对策 |
|---|---|---|---|
| 内网无法访问 CDN | 高（内网环境） | ECharts 渲染失败 | 优先部署本地 bundle 兜底（§4.3）|
| DesignPlanner 增加首轮时延 3-5s | 中 | 用户体验下降 | 可配置关闭（`design_mode=standard`）|
| Mermaid 下线后技术图退化 | 中 | 部分用例质量下降 | PR-1 保留 flag；同步补充 HTML 图模板 |
| ECharts ready 信号 LLM 忘记设置 | 中 | 空白/半成品图 | 静态检查前置拦截，prompt 强调 |
| Agent 重试次数叠加（静态+VL）| 低 | 单次请求时延超长 | 静态检查不触发重试，仅提示 Agent 修复 |

**回滚顺序**：PR-4 → PR-3 → PR-2 → PR-1（逆序）

**配置级快速兜底**：
- `RENDER_HTML_MODE=pure_css`：关闭 JS 增强，回退纯 CSS
- `AGENT_ENABLE_MERMAID=true` + 重启：恢复 Mermaid 工具（PR-1 阶段兜底）

---

## 9. 执行建议（优先级排序）

1. **D1 先行**：验证内网 CDN 可达性（决定 ECharts 路径选择，是核心前提）
2. **D1-D3**：PR-1 HTML Native 化，移除 Mermaid 主链路
3. **D4-D6**：PR-2 渲染增强，ECharts 端到端跑通 10 条基准用例
4. **D7-D10**：PR-3 设计导向 Agent，DesignPlanner 预处理 + 静态检查
5. **D11-D12**：PR-4 质量门控 + Langfuse 维度 + 文档收口

---

## 10. 与 Codex 方案的差异对照

| 项目 | Codex 方案 | 本最终方案 |
|---|---|---|
| PR 顺序 | Native→Design→Renderer→Quality | **Native→Renderer→Design→Quality** |
| DesignPlanner 实现 | 未明确 | **预处理独立 LLM 调用（方案 A）** |
| RepairLoop | 独立外层循环 | **复用 Agent 现有重试，注入修复指令** |
| Tailwind | 预编译（P1）| **P0 不引入，P2 再评估 Full Bundle** |
| 静态检查位置 | 两处选一 | **统一 `app/agent/frontend_design/static_checks.py`** |
| CDN 可达性 | 假设可达 | **D1 前置探针，准备本地 bundle 兜底** |
| `lru_cache` 限制 | 未提及 | **明确文档化：flag 重启生效** |
| `image_qa.py` 清理 | 遗漏 | **纳入 Step 5** |
