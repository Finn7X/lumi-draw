# Lumi Draw 多轮会话支持 Feat 计划（2026-02-18）

## 1. 背景与现状

当前实现是单轮模式，主要证据如下：

- 后端 `app/agent/service.py` 在 `generate_image()` 内每次都新建 `thread_id`，并在 `_create_agent()` 内创建新的 `MemorySaver`，导致跨请求上下文无法延续。
- 后端 `app/api/routes.py` 仅有 `POST /api/v1/generate`，请求体只有 `query`、`user_id`。
- 前端 `frontend/index.html` 只有一个聊天窗口与发送按钮，调用时仅传 `{ query }`，没有会话 ID 和“新对话”状态。

因此，用户的后续追问不会默认基于首图进行修改，而是被当成一次新的独立任务。

## 2. 目标与范围

### 2.1 产品目标

- 支持多轮对话（同一会话内保留上下文）。
- 前端提供“新对话”按钮。
- 默认行为：后续追问被解释为对首次绘制内容的增量修改（除非用户明确说重画/另起主题）。
- 保持现有单轮接口可兼容（避免已有调用方立即中断）。

### 2.2 非目标（本期不做）

- 不做账号体系与跨设备历史同步。
- 不做数据库级长期持久化（V1 先内存 + TTL，V2 再上 Redis/DB）。
- 不做复杂对话列表管理 UI（只实现当前会话 + 新对话按钮）。

## 3. 目标体验（UX）

### 3.1 用户流

1. 用户打开页面，默认在一个新会话里。
2. 首次输入“画一个登录流程图”，系统返回图片。
3. 用户继续输入“把背景改成浅灰，加上异常分支”，系统默认基于上图继续改图。
4. 用户点击“新对话”，清空当前窗口并创建新会话；后续输入不再继承上一个会话上下文。

### 3.2 交互规则

- 同一 `conversation_id` 内：默认增量修改。
- 新会话：上下文隔离。
- 若用户输入“重新画一个”“新主题”这类词，Agent 应按新需求生成（但仍留在同一会话内作为新分支任务）。

## 4. 后端改造方案

## 4.1 API 设计

建议新增会话化接口，同时保留旧接口：

1. `POST /api/v1/conversations`
- 入参：`user_id`（可选）
- 出参：`conversation_id`、`created_at`

2. `POST /api/v1/conversations/{conversation_id}/messages`
- 入参：`query`、`user_id`（可选）
- 出参：
  - `status`
  - `result`（兼容现有文本结果）
  - `conversation_id`
  - `message_id`
  - `last_image_url`（本轮生成的图片 URL，若无则为空）
  - `error`

3. `GET /api/v1/conversations/{conversation_id}/messages`（可选，建议做）
- 用于页面刷新后恢复聊天记录。

4. 兼容接口 `POST /api/v1/generate`
- 继续可用。
- 兼容策略：
  - 如果未传 `conversation_id`，按旧行为单轮执行。
  - 如果传入 `conversation_id`，内部转发到会话消息逻辑。

## 4.2 数据结构

新增会话状态模型（建议 `app/agent/session.py` 或 `app/service/conversation_store.py`）：

- `ConversationState`
  - `conversation_id`
  - `thread_id`（LangGraph 用；建议与 conversation_id 绑定）
  - `user_id`
  - `created_at` / `updated_at`
  - `turn_count`
  - `last_image_url`
  - `last_image_local_path`（可选）
  - `messages`（精简版前端可展示消息）

新增存储抽象：

- `ConversationStore` 接口
- `InMemoryConversationStore` 实现（V1）
- TTL 清理任务（例如 24h 无访问自动清理）

## 4.3 Agent 服务改造（核心）

`app/agent/service.py` 需要改为“服务级长生命周期 agent + 会话线程”：

1. `ImageGenAgenticService.__init__()` 时创建一次：
- `self.memory = MemorySaver()`
- `self.agent = self._create_agent(self.memory)`

2. `generate_image()` 改为接收：
- `query`
- `conversation_id`
- `user_id`

3. `thread_id` 规则：
- 同一会话固定 `thread_id = conversation_id`
- 不再每轮随机生成

4. 每轮执行完成后：
- 提取本轮 `final_output`
- 解析并落库 `last_image_url`（可从最终 markdown 或工具返回中提取）
- 将用户消息和助手消息写入 `ConversationStore`

5. 并发控制：
- 对同一 `conversation_id` 加锁（防止同时两次追问造成状态错乱）

## 4.4 Prompt 与上下文策略

在 `app/agent/prompt.py` 增加多轮规则：

- 若存在会话历史，默认将用户新消息视为“对上一版图片的修改请求”。
- 修改时优先保留未提及部分，仅调整用户点名项。
- 若用户意图不明确且会引起大改，先澄清再绘制。
- 若用户明确要求“重新生成全新图”，则按新任务处理。

同时可在每轮调用前注入一个简短系统上下文（由后端拼接，不暴露给用户）：

- 最近一次图片 URL
- 最近一次用户需求摘要
- 会话当前轮次

## 4.5 Schema 与路由文件调整

- `app/api/schemas.py`
  - 新增 `ConversationCreateRequest/Response`
  - 新增 `ConversationMessageRequest/Response`
  - 扩展 `ImageGenRequest`（可选 `conversation_id`）

- `app/api/routes.py`
  - 新增 `/conversations` 系列路由
  - `generate` 作为兼容层，内部委托会话服务

## 5. 前端改造方案

目标文件：`frontend/index.html`

### 5.1 状态管理

新增前端状态：

- `activeConversationId`
- `isSending`
- `messages`（当前会话消息）

建议最小实现：

- 页面初次加载自动调用 `POST /api/v1/conversations`，得到 `activeConversationId`
- 每次发送消息调用 `/conversations/{id}/messages`

### 5.2 新对话按钮

UI 改动：

- 在 header 增加“新对话”按钮。
- 点击后行为：
  - 清空当前聊天区域
  - 创建新 `conversation_id`
  - 将输入焦点回到文本框

### 5.3 请求与渲染

- 发送消息时附带当前 `conversation_id`。
- 响应成功后：
  - 渲染 `result`
  - 更新本地 `activeConversationId`（以后端返回为准）
- 错误时保留当前会话，不自动切换。

### 5.4 刷新恢复（可选但建议）

- 将 `activeConversationId` 存到 `localStorage`。
- 页面刷新后调用 `GET /conversations/{id}/messages` 恢复历史。

## 6. 迭代拆分（建议 3 个里程碑）

### 里程碑 M1：后端会话化（最小可用）

交付项：

- 会话模型 + 内存存储 + TTL
- 新增 `/conversations` 与 `/conversations/{id}/messages`
- Agent 使用固定 `thread_id`，实现真实多轮
- 单元测试覆盖会话创建与同会话多轮

验收标准：

- 同一 `conversation_id` 连续两次请求，第二次能正确继承上下文。
- 不同 `conversation_id` 完全隔离。

### 里程碑 M2：前端新对话 + 多轮交互

交付项：

- Header 新增“新对话”按钮
- 前端切到会话接口
- 基础本地会话状态管理

验收标准：

- 连续追问可改首图。
- 点击“新对话”后不再继承旧上下文。

### 里程碑 M3：稳定性与兼容

交付项：

- 保留并验证旧 `/generate` 兼容路径
- 同会话并发锁
- 会话清理策略与监控日志
- （可选）刷新恢复历史

验收标准：

- 旧调用方不改代码仍可工作。
- 无明显会话串线、覆盖问题。

## 7. 测试计划

## 7.1 后端测试（pytest）

新增建议文件：

- `tests/test_conversation_api.py`
- `tests/test_conversation_service.py`

核心用例：

1. 创建会话成功，返回合法 `conversation_id`。
2. 同会话两轮对话，第二轮有上下文继承。
3. 新会话与旧会话隔离。
4. 并发提交同一会话，锁生效且顺序一致。
5. 兼容接口 `/generate` 在无 `conversation_id` 时行为不变。

## 7.2 前端联调验证

1. 首轮生成 -> 追问修改 -> 图片确实变化。
2. 点击“新对话”后追问不污染旧图。
3. 接口失败后 UI 状态可恢复（按钮重新可点击）。

## 8. 风险与对策

1. 风险：`MemorySaver` 仅进程内有效，服务重启会丢会话。
- 对策：V1 接受此约束；V2 引入 Redis/DB 持久化。

2. 风险：多实例部署时会话不一致。
- 对策：V2 将 `ConversationStore` 升级为共享存储。

3. 风险：长会话 token 成本升高。
- 对策：保留现有 `SummarizationMiddleware`，并为会话设置最大轮次/摘要压缩策略。

4. 风险：追问歧义导致大幅偏题。
- 对策：在 prompt 中明确“默认增量修改 + 必要时澄清”。

## 9. 回滚与发布策略

- 灰度顺序：先上线后端新接口（不切前端）-> 再切前端。
- 回滚策略：前端可立即退回旧 `/generate` 调用；后端保留兼容逻辑。
- 监控指标：
  - 会话创建成功率
  - 多轮请求成功率
  - 平均每会话轮次
  - 失败率与超时率（按接口维度）

## 10. 预估工作量

- M1：1.5~2.5 天
- M2：0.5~1 天
- M3：0.5~1 天
- 总计：2.5~4.5 天（不含 Redis/DB 持久化）

## 11. 本次代码改动建议清单（落地指引）

- 新增：`app/api/conversation_routes.py`（或继续放 `app/api/routes.py`）
- 新增：`app/agent/conversation_store.py`
- 修改：`app/agent/service.py`（agent 生命周期、thread_id、会话入参）
- 修改：`app/api/schemas.py`（会话请求/响应模型）
- 修改：`app/api/routes.py`（新增会话 API + generate 兼容层）
- 修改：`app/agent/prompt.py`（多轮增量编辑规则）
- 修改：`frontend/index.html`（新对话按钮 + 会话状态 + 新 API 调用）
- 新增：`tests/test_conversation_api.py`

