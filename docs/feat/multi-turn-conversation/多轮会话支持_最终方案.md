# Lumi Draw 多轮会话支持 — 最终实施方案

> 基于初始 Codex 方案 review 后修订，2026-02-19

---

## 1. 背景与现状

| 问题点 | 当前代码位置 | 现状 |
|--------|------------|------|
| 每次请求新建 `MemorySaver` + 新 agent | `service.py` `_create_agent()` | 跨轮上下文完全丢失 |
| `thread_id` 每次随机生成 | `service.py` `generate_image()` | 无法与同一会话绑定 |
| `async` 路由调用同步阻塞函数 | `routes.py` `generate_image()` | 阻塞事件循环；多请求串行 |
| `signal.SIGALRM` 超时 | `service.py` | 主线程有效；线程池中会崩溃 |
| 前端无会话概念 | `frontend/index.html` | 每次发送都是全新独立任务 |

---

## 2. 目标与范围

### 2.1 产品目标

- 同一会话内保留上下文，追问默认作为增量修改。
- 前端提供"新对话"按钮，点击后切换到全新会话。
- 不做账号体系与跨设备历史同步。
- 不做数据库级持久化（V1 内存 + TTL）。

### 2.2 本期不做

- 会话列表 UI（仅"当前会话 + 新对话"）。
- Redis / 数据库持久化（V2 升级）。
- 多实例共享会话（V2 升级）。
- 旧接口兼容（`POST /api/v1/generate` 废弃或直接重构）。

---

## 3. 目标体验（UX）

1. 用户打开页面，前端自动在第一条消息时隐式创建会话。
2. 首次输入"画一个登录流程图"，系统返回图片。
3. 用户继续输入"把背景改成浅灰，加上异常分支"，系统默认基于上图继续修改。
4. 用户点击"新对话"：清空聊天区域，下次发消息时创建新会话，不继承旧上下文。

---

## 4. 后端实施方案

### 4.1 API 设计

废弃 `POST /api/v1/generate`，改为以下接口：

```
POST   /api/v1/conversations
GET    /api/v1/conversations/{conversation_id}/messages  （可选，用于刷新恢复）
POST   /api/v1/conversations/{conversation_id}/messages
```

#### `POST /api/v1/conversations`

创建新会话（前端主动调用，或首条消息前隐式触发）。

- **入参**：`{ "user_id": "string（可选）" }`
- **出参**：`{ "conversation_id": "uuid", "created_at": "ISO8601" }`

#### `POST /api/v1/conversations/{conversation_id}/messages`

会话内发送消息并生成图片。

- **入参**：`{ "query": "string", "user_id": "string（可选）" }`
- **出参**：
  ```json
  {
    "status": "success | error",
    "result": "Agent 返回的 Markdown 文本",
    "conversation_id": "uuid",
    "message_id": "uuid",
    "last_image_url": "string | null",
    "error": "string | null"
  }
  ```
- **错误码**：
  - `404`：`conversation_id` 不存在或已过期
  - `409`：同一 conversation 正在处理中（并发冲突）
  - `408` / `504`：Agent 执行超时

#### `GET /api/v1/conversations/{conversation_id}/messages`（建议做）

返回会话历史（用于页面刷新后恢复）。

- **出参**：`{ "messages": [{ "role": "user|assistant", "content": "string", "image_url": "string|null", "created_at": "ISO8601" }] }`

---

### 4.2 数据结构

#### `ConversationStore`（新增文件：`app/agent/conversation_store.py`）

**分工原则**：
- `MemorySaver` 管理 agent 内部消息历史（工具调用、中间步骤），不对前端暴露。
- `ConversationStore` 只存 metadata + 前端需要展示的精简消息列表，两者不重复。

```python
@dataclass
class DisplayMessage:
    message_id: str           # UUID4
    role: str                 # "user" | "assistant"
    content: str              # 用户原始输入 / Agent 最终回复文本
    image_url: str | None     # 本轮提取出的图片 URL
    created_at: datetime

@dataclass
class ConversationState:
    conversation_id: str      # UUID4，同时用作 LangGraph thread_id
    user_id: str
    created_at: datetime
    updated_at: datetime
    turn_count: int
    last_image_url: str | None
    messages: list[DisplayMessage]

class InMemoryConversationStore:
    """V1：内存存储 + TTL 自动清理（默认 24h）。"""

    def create(self, user_id: str) -> ConversationState: ...
    def get(self, conversation_id: str) -> ConversationState | None: ...
    def update(self, conversation_id: str, ...) -> None: ...
    def append_message(self, conversation_id: str, msg: DisplayMessage) -> None: ...
    def _start_ttl_cleanup(self, ttl_seconds: int = 86400) -> None: ...
```

> `conversation_id` 即为 LangGraph 的 `thread_id`，不需要额外的 `thread_id` 字段。

---

### 4.3 Agent 服务改造（核心）

**文件：`app/agent/service.py`**

#### 变更1：Agent 生命周期上移到服务级别

```python
class ImageGenAgenticService:
    def __init__(self):
        self.memory = MemorySaver()          # 整个服务共享一个 MemorySaver
        self.agent = self._create_agent()    # agent 图本身无可变状态，线程安全
```

所有会话通过不同的 `thread_id`（= `conversation_id`）在同一个 `MemorySaver` 里隔离，这是 LangGraph 的原生设计。

#### 变更1.1：Middleware 参数调整（针对 128k 上下文模型）

原设置基于 ~32k 模型，过于激进（3-4 轮就触发压缩）。单轮 HTML 渲染最多消耗 ~9k tokens，128k 模型可轻松撑 10+ 轮。

| 参数 | 原值 | 新值 | 原因 |
|------|------|------|------|
| `ClearToolUsesEdit.trigger` | 24,000 | 50,000 | 保留更多历史工具输出，提升上下文质量 |
| `ClearToolUsesEdit.keep` | 5 | 3 | HTML 单次输出大（3-8k），3 次够用 |
| `SummarizationMiddleware.trigger` | 26,000 | 90,000 | 仅在真正需要时压缩，避免过早丢失上下文 |
| `SummarizationMiddleware.keep` | 8,000 | 25,000 | 压缩后保留更多近期消息 |
| `SummarizationMiddleware.trim_tokens_to_summarize` | 8,000 | 30,000 | 一次性压缩更大块，减少摘要 LLM 调用次数 |

```python
context_editing = ContextEditingMiddleware(
    edits=[
        ClearToolUsesEdit(
            trigger=50000,
            keep=3,
            placeholder="[Earlier tool output cleared]",
        )
    ],
    token_count_method="approximate",
)

summarization = SummarizationMiddleware(
    model=model,
    trigger=("tokens", 90000),
    keep=("tokens", 25000),
    trim_tokens_to_summarize=30000,
    summary_prefix="[History summary] ",
)
```

#### 变更2：`generate_image()` 接收 `conversation_id`

```python
def generate_image(
    self,
    query: str,
    conversation_id: str,
    user_id: str = "",
) -> str:
    # thread_id 固定为 conversation_id，不再随机生成
    config = {
        "configurable": {"thread_id": conversation_id},
        ...
    }
    result = self.agent.invoke({"messages": [HumanMessage(content=query)]}, config=config)
    return self._extract_final_output(result, conversation_id)
```

#### 变更3：替换 `signal.SIGALRM` 超时

`SIGALRM` 只能在主线程用，改为在线程池中用 `Future.result(timeout=...)` 实现超时：

```python
# 在路由层（见 4.4）使用 asyncio.wait_for + run_in_threadpool
# service.generate_image() 自身不再做信号超时
```

#### 变更4：`last_image_url` 提取

Agent 回复格式固定为 `![描述](url)`，用正则解析：

```python
import re

def _extract_image_url(self, text: str) -> str | None:
    m = re.search(r'!\[[^\]]*\]\(([^)]+)\)', text)
    return m.group(1) if m else None
```

---

### 4.4 路由层改造（核心）

**文件：`app/api/routes.py`**

#### 解决阻塞事件循环问题

`service.generate_image()` 是耗时同步调用，必须用 `run_in_threadpool` 卸载到线程池：

```python
from starlette.concurrency import run_in_threadpool

result = await run_in_threadpool(
    service.generate_image,
    query=request.query,
    conversation_id=conversation_id,
    user_id=request.user_id or "",
)
```

用 `asyncio.wait_for` 包裹实现超时：

```python
result = await asyncio.wait_for(
    run_in_threadpool(service.generate_image, ...),
    timeout=150.0,
)
```

#### 同会话并发锁

锁必须在 `async def` 路由层持有（`asyncio.Lock` 不能跨线程传递）：

```python
_conversation_locks: dict[str, asyncio.Lock] = {}

def _get_lock(conversation_id: str) -> asyncio.Lock:
    if conversation_id not in _conversation_locks:
        _conversation_locks[conversation_id] = asyncio.Lock()
    return _conversation_locks[conversation_id]

@router.post("/conversations/{conversation_id}/messages")
async def send_message(conversation_id: str, request: ConversationMessageRequest):
    conv = store.get(conversation_id)
    if not conv:
        raise HTTPException(404, "Conversation not found or expired")

    lock = _get_lock(conversation_id)
    if lock.locked():
        raise HTTPException(409, "Conversation is busy, please wait")

    async with lock:
        try:
            result = await asyncio.wait_for(
                run_in_threadpool(service.generate_image, ...),
                timeout=150.0,
            )
        except asyncio.TimeoutError:
            raise HTTPException(504, "Image generation timed out")

        image_url = service._extract_image_url(result)
        store.append_message(conversation_id, DisplayMessage(role="assistant", ...))
        ...
        return ConversationMessageResponse(status="success", result=result, ...)
```

> 注意：`_conversation_locks` 是进程内字典，需要在 TTL 清理时一起清理（或容忍少量内存泄漏，locks 本身极轻量）。

---

### 4.5 Prompt 多轮规则

**文件：`app/agent/prompt.py`**

在系统 prompt 末尾增加多轮会话规则（无需注入历史，LangGraph 已通过 `MemorySaver` 自动管理）：

```
## 多轮对话规则

- 若当前会话已有图片生成历史，默认将用户新消息理解为"对上一版图片的增量修改请求"。
- 修改时保留用户未提及的部分，只调整点名修改项。
- 若用户明确说"重新画""换个主题""全新生成"，按全新任务处理（但仍在同一会话内）。
- 若意图不明确且修改幅度可能较大，先用一句话确认用户意图再执行。
```

> `SummarizationMiddleware` 已配置（触发阈值 26000 tokens），长会话上下文会自动压缩，无需额外处理。

---

### 4.6 Schema 调整

**文件：`app/api/schemas.py`**

```python
# 新增
class ConversationCreateRequest(BaseModel):
    user_id: str = ""

class ConversationCreateResponse(BaseModel):
    conversation_id: str
    created_at: str

class ConversationMessageRequest(BaseModel):
    query: str = Field(..., min_length=1)
    user_id: str = ""

class ConversationMessageResponse(BaseModel):
    status: str
    result: str = ""
    conversation_id: str
    message_id: str
    last_image_url: str | None = None
    error: str | None = None

class ConversationHistoryMessage(BaseModel):
    role: str
    content: str
    image_url: str | None = None
    created_at: str

class ConversationMessagesResponse(BaseModel):
    messages: list[ConversationHistoryMessage]
```

---

## 5. 前端改造方案

**文件：`frontend/index.html`**

### 5.1 新增状态

```javascript
let activeConversationId = null;  // 当前会话 ID
let isSending = false;
```

### 5.2 会话生命周期

**隐式创建**：首次发送消息时，若 `activeConversationId` 为 null，先调用 `POST /api/v1/conversations` 获取 ID，再发消息。

```javascript
async function ensureConversation() {
  if (activeConversationId) return;
  const resp = await fetch('/api/v1/conversations', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({}),
  });
  const data = await resp.json();
  activeConversationId = data.conversation_id;
}
```

**发消息**：

```javascript
await ensureConversation();
const resp = await fetch(`/api/v1/conversations/${activeConversationId}/messages`, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ query: text }),
  signal: controller.signal,
});
```

### 5.3 新对话按钮

**Header 改动**（在标题右侧增加按钮）：

```html
<header>
  <span>Lumi Draw</span>
  <button id="new-chat" title="新对话">＋ 新对话</button>
</header>
```

**点击行为**：

```javascript
document.getElementById('new-chat').addEventListener('click', () => {
  activeConversationId = null;
  chat.innerHTML = '';
  msgInput.focus();
  // 可选：localStorage.removeItem('activeConversationId');
});
```

### 5.4 刷新恢复（推荐做）

```javascript
// 页面加载时
const saved = localStorage.getItem('activeConversationId');
if (saved) {
  activeConversationId = saved;
  // 调用 GET /api/v1/conversations/{id}/messages 恢复历史
  restoreHistory(activeConversationId);
}

// 每次创建/确认会话后
localStorage.setItem('activeConversationId', activeConversationId);
```

### 5.5 错误处理

- `409`：提示"上一条消息仍在处理中，请稍候"，按钮保持禁用直到用户看到提示后重新启用。
- `404`：提示"会话已过期，已自动开启新对话"，清空 `activeConversationId` 并重试。

---

## 6. 文件改动清单

| 操作 | 文件 | 改动内容 |
|------|------|---------|
| 新增 | `app/agent/conversation_store.py` | `ConversationState`, `DisplayMessage`, `InMemoryConversationStore` |
| 修改 | `app/agent/service.py` | `MemorySaver` + agent 移到 `__init__`；`generate_image` 接收 `conversation_id`；去除 `signal.SIGALRM`；新增 `_extract_image_url` |
| 修改 | `app/api/schemas.py` | 新增会话系列 Schema，删除旧 `ImageGenRequest/Response` |
| 修改 | `app/api/routes.py` | 新增 `/conversations` 系列路由；改用 `run_in_threadpool` + `asyncio.wait_for`；并发锁逻辑 |
| 修改 | `app/agent/prompt.py` | 新增多轮规则段落 |
| 修改 | `frontend/index.html` | 新对话按钮；状态管理；接口切换；刷新恢复 |
| 新增 | `tests/test_conversation_store.py` | Store 单元测试 |
| 新增 | `tests/test_conversation_api.py` | API 集成测试 |

---

## 7. 迭代里程碑

### M1：后端会话化（核心）

**交付项**：
- `InMemoryConversationStore`（含 TTL 清理）
- 新增 `/conversations` 与 `/conversations/{id}/messages` 路由
- `service.py` 改为单 `MemorySaver` + `conversation_id` 固定 `thread_id`
- 移除 `signal.SIGALRM`，改为 `asyncio.wait_for` 超时
- 同会话并发锁

**验收标准**：
- 同一 `conversation_id` 两次请求，第二次能感知第一次的上下文。
- 不同 `conversation_id` 完全隔离。
- 并发两条同会话请求，第二条收到 `409`。

### M2：前端多轮交互

**交付项**：
- 新对话按钮
- 隐式会话创建
- 切换为 `/conversations/{id}/messages` 接口
- `localStorage` 持久化 `conversation_id`
- 409/404 错误处理

**验收标准**：
- 连续追问可在原图基础上修改。
- 点击"新对话"后，新消息不继承旧上下文。
- 页面刷新后若会话未过期，可恢复历史消息。

### M3：稳定性与测试

**交付项**：
- 单元测试：`ConversationStore` CRUD、TTL 清理
- 集成测试：创建会话、多轮对话、并发锁、会话过期
- 前端联调验证
- 结构化日志补充（conversation_id 贯穿全链路）
- `GET /conversations/{id}/messages` 接口（如 M1/M2 未完成）

**验收标准**：
- 核心用例测试通过率 100%。
- 无明显会话串线或覆盖问题。

---

## 8. 风险与对策

| 风险 | 对策 |
|------|------|
| 服务重启丢失全部会话（`MemorySaver` 进程内） | V1 接受；V2 接入 `LangGraph` 的 `PostgresSaver` / `RedisSaver` |
| 多实例部署时会话不一致 | V2 升级 `ConversationStore` 为 Redis 共享存储 |
| 长会话 token 成本升高 | `SummarizationMiddleware` 已就位（26k token 触发压缩到 8k） |
| `_conversation_locks` 字典随会话增长 | TTL 清理时同步删除对应 lock；locks 本身内存极小可接受 |
| 追问歧义导致大幅偏题 | Prompt 明确"默认增量修改 + 意图不明时先确认"规则 |

---

## 9. 测试用例清单

### 后端（pytest）

```
test_create_conversation_returns_valid_id
test_send_message_to_nonexistent_conversation_returns_404
test_second_turn_inherits_context            # 核心：上下文连续性
test_different_conversations_are_isolated    # 核心：上下文隔离
test_concurrent_same_conversation_returns_409
test_conversation_expires_after_ttl
test_extract_image_url_from_markdown
```

### 前端联调

1. 首轮生成 → 追问修改 → 图片确实变化（与首图相关）。
2. 点击"新对话" → 追问 → 不继承旧图上下文。
3. 发送时点"新对话" → 等待期间不应中断当前请求。
4. 接口 409 → UI 给出提示，按钮重新可点击。
5. 页面刷新 → 历史消息恢复显示。

---

## 10. 预估工作量

| 里程碑 | 估时 |
|--------|------|
| M1（后端会话化） | 1.5 ~ 2 天 |
| M2（前端改造） | 0.5 ~ 1 天 |
| M3（测试与稳定） | 0.5 ~ 1 天 |
| **合计** | **2.5 ~ 4 天** |
